#include "stdafx.h"
#include "DataTypes.h"
#include <iostream>
#include "moduls5306.h"

// ============================= Сидоров ====================================
//Назначение:
//Функция для сравнения двух натуральных чисел
//
//Возвращаемое значение:
//2 - если первое число больше
//1 - если второе число больше
//0 - если числа равны
//
//Параметры:
//Число №1
//Число №2

int COM_NN_D(DM_N n1, DM_N n2)
{
	if (n1.n > n2.n)				//Сравниваем длины чисел
		return 2;
	else
		if (n1.n < n2.n)
			return 1;

	for (int i = n1.n; i >= 0; i--)	//Если длины чисел равны, то переходим к поразрядному сравнению
		if (n1.a[i] > n2.a[i])
			return 2;
		else
			if (n1.a[i] < n2.a[i])
				return 1;

	return 0;
}

//======
//Назначение:
//Функция для умножения натурального числа на 10 в степени k
//
//Возвращаемое значение:
//Отсутствует
//
//Параметры:
//Изменяемое число
//Степень множителя 10

void MUL_Nk_N(DM_N &obj, unsigned short k)
{
	DM_N temp;		//Временная переменная, хранящая старые данные
	temp.a = obj.a;
	temp.n = obj.n;

	short uselessZeroes = 0;
	for (short i = temp.n - 1; i >= 0 && obj.a[i] == 0; i--)
		++uselessZeroes;

	if (k > uselessZeroes)
		obj.n += k - uselessZeroes;
	obj.a = new unsigned short[obj.n];

	for (short i = obj.n - 1; i >= 0; i--)
		if (i < k)
			obj.a[i] = 0;
		else
			obj.a[i] = temp.a[i - k];
}

//======
//Назначение:
//Производная многочлена
//
//Возвращаемое значение:
//Многочлен
//
//Параметры:
//Многочлен, производная которого ищется

DM_P DER_P_P(const DM_P &obj)
{
	DM_P *result = new DM_P;
	result->c = new DM_Q[obj.m];
	for (int i = 1; i <= obj.m; i++)
		result->c[i - 1] = obj.c[i] * i;
	result->m = obj.m - 1;
	return *result;
}


// ============================= Ершов ====================================
//Об авторе 
//Ершов Даниил Константинович ФКТИ Гр.№5306  
//E-Mail: daniilershov2015@gmail.com

//Функция преобразования натурального числа в целое 
DM_Z TRANS_N_Z(DM_N nat) 
{
	DM_Z cel;         //целое число которое будет возвращать функция
	cel.n = nat.n;    //запоминаем старший разряд
	cel.a = (short unsigned int*)malloc(sizeof(short unsigned int)*cel.n); //выделяем память под массив цифр
	for (int i = 0; i < cel.n; i++)   //присваиваем значения разрядов натурального числа целому
		cel.a[i] = nat.a[i];
	cel.b = 0; // устанавливаем знак числа
	return cel; // вовзращаем целое число
}

//Функция определения положительности числа
short unsigned int POZ_Z_D(DM_Z cel)  
{
	short unsigned int sign;	//Функия хранящая значение 1, если число положительное,
								//2 если число отрицательное и 0 если число равно 0
	bool zero = true;
	for (int i = 0; i < cel.n && zero; i++)
		zero = (cel.a[i] == 0);		//Если все числа в массиве равны 0, следовательно число равно 0

	if (zero)
		sign = 0;
	else
		if (cel.b == 0)
			sign = 1;
		else
			sign = 2;

	return sign;
}

//Функция умножения целого числа на -1
void MUL_Zm_Z(DM_Z *cel) 
{
	if(cel->n != 1 || cel->a[0] != 0)	//Если число не ноль
		cel->b = !(cel->b);		//Инвертируем поле знака
}

// ============================= Томинг ====================================



// ============================= Гуляев ====================================